/*
 * Copyright (c) 2014 syuilo All rights reserved.
 * Thanks for Akari, Chinatsu, Yui, Kyoko and you.
 *                                                      syuilo
 **************************************************************** */

library Notex2;

void scream() {
	print("うー！にゃー！" * 4);
}

String indent(int hierarchy) {
	//return ("\t" * hierarchy);
	return ("    " * hierarchy);
}

String htmlEscape(String source) {
	String html = source;
	html = html.replaceAll('<', '&lt;');
	html = html.replaceAll('>', '&gt;');
	return html;
}

/**
 * Token
 */
class Token {
	int id = 0;
	String token = "";
	String lexeme = "";
}

abstract class Element {
	String name;
	Element parent;
	List<Element> children = new List();
	Map<String, String> attributes = new Map();
	
	/**
	 * HTML文字列を生成します。
	 */
	String toHtml([String id = '', int hierarchy = 0]);
	
	/**
	 * 目次のHTML文字列を生成します。
	 */
	String genelateTableOfContentsHtml(String id) {
		// ダックタイピング的な
		if (this.name == 'section') {
			String html = "";
			if (this.childFind('section')) {
				for (Element element in this.children) {
	        			html += element.genelateTableOfContentsHtml(id);
	        		}
	        		return '<li class="section"><a href="#${id}-${this.number}">${this.title}</a><ol>$html</ol></li>';
			} else {
				return '<li><a href="#${id}-${this.number}">${this.title}</a></li>';
			}
		} else {
			return '';
		}
	}
	
	/**
	 * 自分の親に指定された名前を持つ要素が存在するかどうかを取得します。
	 */
	bool parentFind(name) {
		return this.parent.parentSearch(name);
	}
	
	bool parentSearch(String name) {
		if (name == this.name)
			return true;
		else
			return this.parent.parentSearch(name);
	}
	
	/**
	 * 自分の子に指定された名前を持つ要素が存在するかどうかを取得します。
	 */
	bool childFind(String name) {
		for (Element element in this.children) {
			if (element.childSearch(name)) {
				return true;
			}
		}
		return false;
	}
	
	bool childSearch(String name) {
		if (name == this.name) {
			return true;
		} else {
			for (Element element in this.children) {
        			if (element.childSearch(name)) {
        				return true;
        			}
        		}
			return false;
		}
	}
}

class Article extends Element {
	String name = 'article';
	String title = "";
	
	bool parentFind(name) {
		return false;
	}
	
	bool parentSearch(String name) {
		if (name == 'article')
			return true;
		else
			return false;
	}
	
	String toHtml([String id = '', int hierarchy = 0]) {
		String html = "";
		for (Element element in this.children) {
			html += element.toHtml(id, hierarchy + 1);
		}
		return "<!-- Generated by Notex2 (c) syuilo. -->\n<article>\n$html</article>";
	}
	
	String genelateTableOfContentsHtml(String id) {
		String html = "";
		for (Element element in this.children) {
			html += element.genelateTableOfContentsHtml(id);
		}
		return '<div class="tableOfContents" id="${id}-tableOfContents"><ol>$html</ol></div>';
	}
}

class Text extends Element {
	String name = 'text';
	String text = "";
	
	bool childFind(String name) {
		return false;
	}
	
	bool childSearch(String name) {
		if (name == this.name) {
			return true;
		} else {
			return false;
		}
	}
	
	String toHtml([String id = '', int hierarchy = 0]) {
		return htmlEscape(this.text);
	}
}

/*
class Div extends Element {
	List<Element> children;
}
*/

class Section extends Element {
	String name = 'section';
	int hierarchy;
	String title = "";
	int number = 0;
	
	String toHtml([String id = '', int hierarchy = 0]) {
		String html = "";
		String attribute = "";
		String h = "h$hierarchy";
		for (Element element in this.children) {
			html += element.toHtml(id, hierarchy + 1);
		}
		/*
		for (String key in this.attributes.keys) {
			attribute += ' $key="${this.attributes[key]}"';
                }
                */
		if (id != '') {
			attribute = ' id="#${id}-${this.number}"';
		}
		return indent(hierarchy) + "<section$attribute>\n"
				+ indent(hierarchy + 1) + "<$h>$title</$h>\n"
				+ html
				+ indent(hierarchy) + "</section>\n";
	}
}

/**
 * Paragraph
 */
class Paragraph extends Element {
	String name = 'paragraph';
	
	String toHtml([String id = '', int hierarchy = 0]) {
		String html = "";
		for (Element element in this.children) {
			html += element.toHtml();
		}
		html = html.trim();
		//html = html.replaceAll(new RegExp(r'\n{2, 0}'), '\n');
		html = html.replaceAll('\n', '</br>');
		if (html != '') {
			return indent(hierarchy) + "<p>$html</p>\n";
		} else {
			return '';
		}
	}
}

class Strong extends Element {
	String name = 'strong';
	
	String toHtml([String id = '', int hierarchy = 0]) {
		String html = "";
		for (Element element in this.children) {
			html += element.toHtml();
		}
		return "<strong>$html</strong>";
	}
}

class Keyword extends Element {
	String name = 'keyword';
	
	String toHtml([String id = '', int hierarchy = 0]) {
		String html = "";
		for (Element element in this.children) {
			html += element.toHtml();
		}
		return "<b>$html</b>";
	}
}

class Strike extends Element {
	String name = 'strike';
	
	String toHtml([String id = '', int hierarchy = 0]) {
		String html = "";
		for (Element element in this.children) {
			html += element.toHtml();
		}
		return "<del>$html</del>";
	}
}

class Link extends Element {
	String name = 'link';
	String url = "";
	
	String toHtml([String id = '', int hierarchy = 0]) {
		String html = "";
		for (Element element in this.children) {
			html += element.toHtml();
		}
		return "<a href=\"$url\" target=\"_blank\">$html</a>";
	}
}

class Image extends Element {
	String name = 'image';
	String url = "";
	
	String toHtml([String id = '', int hierarchy = 0]) {
		return "<img src=\"$url\" alt=\"image\"/>";
	}
}

class Code extends Element {
	String name = 'code';
	String code = "";
	String lang = "plain";
	
	String toHtml([String id = '', int hierarchy = 0]) {
		return indent(hierarchy) + "<pre><code data-lang=\"$lang\">$code</code></pre>\n";
	}
}

class Blockquote extends Element {
	String name = 'blockquote';
	
	String toHtml([String id = '', int hierarchy = 0]) {
		String html = "";
		for (Element element in this.children) {
			html += element.toHtml(id, hierarchy + 1);
		}
		return indent(hierarchy) + "<blockquote>\n$html" + indent(hierarchy) + "</blockquote>\n";
	}
}

class EList extends Element {
	String name = 'list';
	String type = "unordered"; // unordered or ordered
	
	String toHtml([String id = '', int hierarchy = 0]) {
		String html = "";
		for (Element element in this.children) {
			html += element.toHtml(id, hierarchy + 1);
		}
		if (this.type == "ordered") {
			return indent(hierarchy) + "<ol>\n$html" + indent(hierarchy) + "</ol>\n";
		} else {
			return indent(hierarchy) + "<ul>\n$html" + indent(hierarchy) + "</ul>\n";
		}
	}
}

class EListItem extends Element {
	String name = 'list_item';
	
	String toHtml([String id = '', int hierarchy = 0]) {
		String html = "";
		for (Element element in this.children) {
			html += element.toHtml();
		}
		return indent(hierarchy) + "<li>$html</li>\n";
	}
}

/**
 * コンパイラ本体です。
 */
class Notex2 {
	String source;
	String id = "article";
	List<Token> tokens;
	int pos = 0; // トークンリーダの位置
	int sectionCount = 0;
	
	Notex2(String source, [String articleId = "article"]) {
		this.source = source;
		this.id = articleId;
		this.tokens = new List();
	}
	
	Article compile() {
		this.tokens = this.lexicalgenerater();
		Article article = new Article();
		article.title = this.id;
		article.children = this.analyze(article, (token){return false;});
		return article;
	}
	
	/**
	 * 字句解析器。トークンリストを生成します。
	 */
	List<Token> lexicalgenerater() {
		List<Token> tokens = new List();
		int pos = 0;
		int id = 0;
		Token tokeniza() {
			Token token = new Token();
			bool text = false;
			if (this.source.length == 0) {
				return null;
			}
			while (pos < this.source.length) {
				String char = this.source[pos];
				pos++;
				switch (char) {
					case '\\':
						if (!text) {
							token.token = 'escape';
							token.lexeme = char;
						} else {
							pos--;
						}
						return token;
					case ' ':
						if (!text) {
							token.token = 'space';
							token.lexeme = char;
						} else {
							pos--;
						}
						return token;
					case '\n':
						if (!text) {
							token.token = 'newline';
							token.lexeme = char;
						} else {
							pos--;
						}
						return token;
					case '0':
					case '1':
					case '2':
					case '3':
					case '4':
					case '5':
					case '6':
					case '7':
					case '8':
					case '9':
						if (!text) {
							token.token = 'number';
							token.lexeme = char;
						} else {
							pos--;
						}
						return token;
					case '\'':
						if (!text) {
							token.token = 'quotation';
							token.lexeme = char;
						} else {
							pos--;
						}
						return token;
						
					case '\"':
						if (!text) {
							token.token = 'double_quotation';
							token.lexeme = char;
						} else {
							pos--;
						}
						return token;
					case '.':
						if (!text) {
							token.token = 'period';
							token.lexeme = char;
						} else {
							pos--;
						}
						return token;
					case '@':
						if (!text) {
							token.token = 'at_mark';
							token.lexeme = char;
						} else {
							pos--;
						}
						return token;
					case '#':
						if (!text) {
							token.token = 'sharp';
							token.lexeme = char;
						} else {
							pos--;
						}
						return token;
					case '*':
						if (!text) {
							token.token = 'asterisk';
							token.lexeme = char;
						} else {
							pos--;
						}
						return token;
					case '-':
						if (!text) {
							token.token = 'hyphen';
							token.lexeme = char;
						} else {
							pos--;
						}
						return token;
					case '~':
						if (!text) {
							token.token = 'tilde';
							token.lexeme = char;
						} else {
							pos--;
						}
						return token;
					case '(':
						if (!text) {
							token.token = 'open_bracket';
							token.lexeme = char;
						} else {
							pos--;
						}
						return token;
					case ')':
						if (!text) {
							token.token = 'close_bracket';
							token.lexeme = char;
						} else {
							pos--;
						}
						return token;
					case '[':
						if (!text) {
							token.token = 'open_square_bracket';
							token.lexeme = char;
						} else {
							pos--;
						}
						return token;
					case ']':
						if (!text) {
							token.token = 'close_square_bracket';
							token.lexeme = char;
						} else {
							pos--;
						}
						return token;
					case '<':
						if (!text) {
							token.token = 'greater_than';
							token.lexeme = char;
						} else {
							pos--;
						}
						return token;
					case '>':
						if (!text) {
							token.token = 'less_than';
							token.lexeme = char;
						} else {
							pos--;
						}
						return token;
					case '!':
						if (!text) {
							token.token = 'exclamation_mark';
							token.lexeme = char;
						} else {
							pos--;
						}
						return token;
					default:
						text = true;
						token.token = 'text';
						token.lexeme += char;
						break;
				}
			}
			return token;
		}
		
		while (pos < this.source.length) {
			var token = tokeniza();
			token.id = id;
			id++;
			//print("${token.id}\t${token.token}\t: ${token.lexeme}");
			tokens.add(token);
		}
		
		Token token = new Token();
		token.id = id;
		token.token = 'eof';
		token.lexeme = '';
		tokens.add(token);
		
		return tokens;
	}
	
	Element analyzeSection(Element parent, [inspecter(Token token), List<String> filter]) {
		if (filter != null) {
			if (filter.indexOf('section') > -1) {
				return null;
			}
		}
		return this.generateSection(parent);
	}
	
	Element analyzeParagraph(Element parent, [inspecter(Token token), List<String> filter]) {
		if (filter != null) {
			if (filter.indexOf('paragraph') > -1) {
				return null;
			}
		}
		return this.generateParagraph(parent, inspecter);
	}
	
	Element analyzeKeyword(Element parent, [inspecter(Token token), List<String> filter]) {
		if (filter != null) {
			if (filter.indexOf('keyword') > -1) {
				return null;
			}
		}
		return this.generateKeyword(parent, inspecter, filter);
	}
	
	Element analyzeStrong(Element parent, [inspecter(Token token), List<String> filter]) {
		if (filter != null) {
			if (filter.indexOf('strong') > -1) {
				return null;
			}
		}
		return this.generateStrong(parent, inspecter, filter);
	}
	
	Element analyzeStrike(Element parent, [inspecter(Token token), List<String> filter]) {
		if (filter != null) {
			if (filter.indexOf('strike') > -1) {
				return null;
			}
		}
		return this.generateStrike(parent, inspecter, filter);
	}
	
	Element analyzeLink(Element parent, [inspecter(Token token), List<String> filter]) {
		if (filter != null) {
			if (filter.indexOf('link') > -1) {
				return null;
			}
		}
		return this.generateLink(parent, inspecter, filter);
	}
	
	Element analyzeImage(Element parent, [inspecter(Token token), List<String> filter]) {
		if (filter != null) {
			if (filter.indexOf('image') > -1) {
				return null;
			}
		}
		return this.generateImage(parent);
	}
	
	Element analyzeList(Element parent, [inspecter(Token token), List<String> filter]) {
		if (filter != null) {
			if (filter.indexOf('list') > -1) {
				return null;
			}
		}
		return this.generateList(parent);
	}
	
	Element analyzeBlockquote(Element parent, [inspecter(Token token), List<String> filter]) {
		if (filter != null) {
			if (filter.indexOf('blockquote') > -1) {
				return null;
			}
		}
		return this.generateBlockquote(parent);
	}
	
	Element analyzeCode(Element parent, [inspecter(Token token), List<String> filter]) {
		if (filter != null) {
			if (filter.indexOf('code') > -1) {
				return null;
			}
		}
		return this.generateCode(parent);
	}
	
	bool checkBlockquote(Token token) {
		return (token.token == 'newline') && (this.tokens[token.id + 1].token == 'newline') && (this.tokens[token.id + 2].token == 'less_than');
	}
	
	bool checkCode(Token token) {
		return (token.token == 'quotation') && (this.tokens[token.id + 1].token == 'quotation') && (this.tokens[token.id + 2].token == 'quotation');
	}
	
	bool checkImage(Token token) {
		return (token.token == 'exclamation_mark') && (this.tokens[token.id + 1].token == 'open_bracket');
	}
	
	bool checkKeyword(Token token) {
		return (token.token == 'asterisk') && (this.tokens[token.id + 1].token != 'asterisk');
	}
	
	bool checkLink(Token token) {
		return (token.token == 'open_square_bracket');
	}
	
	bool checkList(Token token) {
		return (token.token == 'newline') && ((this.tokens[token.id + 1].token == 'hyphen') || ((this.tokens[token.id + 1].token == 'number') && (this.tokens[token.id + 2].token == 'period')));
	}
	
	bool checkSection(Token token) {
		return (token.token == 'newline') && (this.tokens[token.id + 1].token == 'sharp');
	}
	
	bool checkStrike(Token token) {
		return (token.token == 'tilde') && (this.tokens[token.id + 1].token == 'tilde');
	}
	
	bool checkStrong(Token token) {
		return (token.token == 'asterisk') && (this.tokens[token.id + 1].token == 'asterisk');
	}
	
	/**
	 * トークンを解析し、要素を生成します。
	 * スキャンが開始される位置は現在のトークンリーダに基づきます。
	 * 
	 * @param Element parent 生成される要素の親になる要素。
	 * @param function(Token token) inspector 設定するとトークンの読み出しごとに読み出したトークンを与えて呼び出されます。[true]を返すとスキャンは直ちに終了します。
	 * @param List<String> filter 生成を禁止する要素の名称の配列。設定すると、ここに記載されている要素は生成対象にしません。
	 * 
	 * @return 生成された要素の配列。
	 */
	List<Element> analyze(Element parent, [inspecter(Token token), List<String> filter]) {
		List<Element> elements = new List();
		this.scan((Token token) {
			if (inspecter != null) {
				if (inspecter(token)) {
					return true;
				}
			}
			if (token.id == 0) {
				switch (token.token) {
					case 'sharp':
						this.back();
						Element element = analyzeSection(parent, inspecter, filter);
        					if (element != null) {
        						elements.add(element);
        						this.next();
        					}
        					break;
				}
			}
			
			if (!parent.parentSearch('paragraph')) {
				Element element;
				if (checkKeyword(token) ||
					checkStrong(token) ||
					checkStrike(token) ||
					checkLink(token)
				) {
					this.back();
					element = analyzeParagraph(parent, inspecter, filter);
					
					if (element != null) {
        					elements.add(element);
						token = this.read();
        				} else {
        					this.next();
        				}
				}
			}

			switch (token.token) {
				case 'eof':
					return true;
				case 'escape':
					// 必殺技レキシカルトークンリライト (時空書き換え(危険))
					this.next();
					this.tokens[token.id + 1].token = 'text';
					break;
				default:
					Element element;
					if (checkBlockquote(token)) {
						element = analyzeBlockquote(parent, inspecter, filter);
					} else if (checkCode(token)) {
						element = analyzeCode(parent, inspecter, filter);
					} else if (checkImage(token)) {
						element = analyzeImage(parent, inspecter, filter);
					} else if (checkKeyword(token)) {
                                        	element = analyzeKeyword(parent, inspecter, filter);
					} else if (checkLink(token)) {
						element = analyzeLink(parent, inspecter, filter);
					} else if (checkList(token)) {
						element = analyzeList(parent, inspecter, filter);
					} else if (checkSection(token)) {
						element = analyzeSection(parent, inspecter, filter);
					} else if (checkStrike(token)) {
						element = analyzeStrike(parent, inspecter, filter);
					} else if (checkStrong(token)) {
						element = analyzeStrong(parent, inspecter, filter);
					} else {
						if (!parent.parentSearch('paragraph')) {
							Element element = analyzeParagraph(parent, inspecter, filter);
        	    					if (element != null) {
        	    						elements.add(element);
        	    					} else {
        	    						elements.add(this.generateText(parent, inspecter, filter));
        	    						this.next();
        	    					}
        	    					break;
        					}
					}
					
					if (element != null) {
						elements.add(element);
					} else {
						elements.add(this.generateText(parent, inspecter, filter));
					}
					this.next();
					break;
			}
		});
		return elements;
	}
	
	/**
	 * テキストを解析します。テキストは子要素を持つことはなく、最小の単位です。
	 */
	Text generateText(Element parent, [inspecter(token), List<String> filter]) {
		Text text = new Text();
		text.parent = parent;
		this.scan((Token token) {
			if (inspecter != null) {
				if (inspecter(token)) {
					return true;
				}
			}
			if (checkBlockquote(token)) {
				return true;
			} else if (checkCode(token)) {
				return true;
			} else if (checkImage(token)) {
				return true;
			} else if (checkLink(token)) {
				return true;
			} else if (checkList(token)) {
				return true;
			} else if (checkSection(token)) {
				return true;
			} else if (checkStrike(token)) {
				return true;
			} else if (checkStrong(token)) {
				return true;
			} else {
				text.text = token.lexeme;
				 return true;
			}
			this.next();
		});
		return text;
	}
	
	/**
	 * Paragraphを解析します。
	 */
	Paragraph generateParagraph(Element parent, [inspecter(token)]) {
		Paragraph p = new Paragraph();
		p.parent = parent;
		p.children = this.analyze(p, (token) {
			if (checkSection(token)) {
				return true;
			} else if (checkList(token)) {
				return true;
			} else if (checkBlockquote(token)) {
				return true;
			} else if (checkCode(token)) {
				return true;
			} else {
				// ?
				if (inspecter != null) {
        				if (inspecter(token)) {
        					return true;
        				}
        			}
				return false;
			}
		});
		return p;
	}
	
	/**
	 * セクションを解析します。
	 */
	Section generateSection(Element parent) {
		this.sectionCount++;
		Section section = new Section();
		section.parent = parent;
		section.hierarchy = 0;
		section.title = "";
		section.number = this.sectionCount;
		bool secEnd = false;
		
		this.next();
		this.scan((Token token) {
			if (!secEnd) {
				switch (token.token) {
					case 'sharp':
						if (section.title == "") {
							section.hierarchy++;
						} else {
							secEnd = true;
						}
						break;
					case "newline":
						//print("["+("-"*(section.hierarchy-1))+"> セクションの開始 h:${section.hierarchy} title:${section.title}]");
						secEnd = true;
						break;
					default:
						section.title += token.lexeme;
						break;
				}
			} else {
				section.children = this.analyze(section, (token) {
					if (checkSection(token)) {
						// 次に始まるセクションの階層を調べる
						// もし自分より上か同階層なら自分のセクションは終了
						
						int nextSectionHierarchy = 0;
						int step = 0;
						this.next();
						this.scan((Token secToken) {
							if (secToken.token == 'sharp') {
								nextSectionHierarchy++;
								step++;
								this.next();
								return false;
							} else {
								return true;
							}
							step++;
							this.next();
						});
						// 階層を調べるために進めたトークンリーダを元の位置まで巻き戻す
						this.back(step + 1);
						if (nextSectionHierarchy <= section.hierarchy) {
							this.back();
							return true;
						} else {
							return false;
						}
					} else {
						return false;
					}
				});
				return true;
			}
			this.next();
		});
		//print("["+("-"*(section.hierarchy-1))+"< セクションの終了 h:${section.hierarchy} title:${section.title}]");
		section.title = htmlEscape(section.title);
		return section;	
	}
	
	/**
	 * Keywordを解析します。
	 */
	Keyword generateKeyword(Element parent, [inspecter(token), List<String> filter]) {
		Keyword keyword = new Keyword();
		keyword.parent = parent;
		this.next();
		if (filter == null) {
			filter = ['paragraph'];
		} else {
			filter.add('paragraph');
		}
		keyword.children = this.analyze(keyword, (token) {
			return (token.token == 'asterisk') && (this.tokens[token.id + 1].token != 'asterisk');
		}, filter);
		return keyword;
	}
	
	/**
	 * Strongを解析します。
	 */
	Strong generateStrong(Element parent, [inspecter(token), List<String> filter]) {
		Strong strong = new Strong();
		strong.parent = parent;
		this.next(2);
		if (filter == null) {
			filter = ['paragraph'];
		} else {
			filter.add('paragraph');
		}
		strong.children = this.analyze(strong, (token) {
			return (token.token == 'asterisk') && (this.tokens[token.id + 1].token == 'asterisk');
		}, filter);
		this.next();
		return strong;
	}
	
	/**
	 * Strikeを解析します。
	 */
	Strike generateStrike(Element parent, [inspecter(token), List<String> filter]) {
		Strike strike = new Strike();
		strike.parent = parent;
		this.next(2);
		if (filter == null) {
			filter = ['paragraph'];
		} else {
			filter.add('paragraph');
		}
		strike.children = this.analyze(strike, (token) {
			return (token.token == 'tilde' && this.tokens[token.id + 1].token == 'tilde');
		}, filter);
		this.next();
		return strike;
	}
	
	/**
	 * リンクを解析します。
	 */
	Link generateLink(Element parent, [inspecter(token), List<String> filter]) {
		Link link = new Link();
		link.parent = parent;
		this.next();
		this.scan((Token token) {
			link.children = this.analyze(link, (token) {
				return token.token == 'close_square_bracket';
			}, filter);
			return true;
		});
		this.next(2);
		this.scan((Token token) {
			switch (token.token) {
				case 'close_bracket':
					return true;
				default:
					link.url += token.lexeme;
					break;
			}
			this.next();
		});
		link.url = htmlEscape(link.url);
		return link;
	}
	
	/**
	 * Imgを生成します。
	 */
	Image generateImage(Element parent) {
		Image img = new Image();
		img.parent = parent;
		this.next(2);
		this.scan((Token token) {
			switch (token.token) {
				case 'close_bracket':
					return true;
				default:
					img.url += token.lexeme;
					break;
			}
			this.next();
		});
		img.url = htmlEscape(img.url);
		return img;
	}
	
	/**
	 * Blockquoteを解析します。
	 */
	Blockquote generateBlockquote(Element parent, [inspecter(token), List<String> filter]) {
		Blockquote blockquote = new Blockquote();
		blockquote.parent = parent;
		this.next(3);
		blockquote.children = this.analyze(blockquote, (token) {
			if (token.token == 'newline' && this.tokens[token.id + 1].token == 'newline') {
				return true;
			}
			return false;
		}, filter);
		return blockquote;
	}
	
	/**
	 * コードを解析します。
	 */
	Code generateCode(Element parent) {
		Code code = new Code();
		code.parent = parent;
		this.next(3);
		if (this.read().token == 'at_mark') {
			this.next();
			code.lang = "";
			this.scan((Token token) {
	    			switch (token.token) {
	    				case 'newline':
	    					this.next();
	    					return true;
	    				default:
	    					code.lang += token.lexeme;
	    					break;
	    			}
	    			this.next();
	    		});
		}
		this.scan((Token token) {
			switch (token.token) {
				case 'escape':
					this.next();
                        		code.code += this.read().lexeme;
					break;
				case 'quotation':
					if (this.read(1).token == 'quotation' &&
						this.read(2).token == 'quotation') {
						this.next(3);
						return true;
					}
					continue text;
			text:
				default:
					code.code += token.lexeme;
					break;
			}
			this.next();
		});
		code.code = htmlEscape(code.code.trim());
		code.lang = htmlEscape(code.lang);
		return code;
	}
	
	/**
	 * リストを生成します。
	 */
	EList generateList(Element parent) {
		EList list = new EList();
		list.parent = parent;
		list.type = this.read(1).token == 'number' ? 'ordered' : 'unordered';
		this.next();
		this.scan((Token token) {
			if (list.type == 'ordered') {
				this.next(2);
			} else {
				this.next();
			}
			EListItem item = new EListItem();
			item.children = this.analyze(list, (token) {
				return token.token == 'newline';
			}, ['paragraph']);
			list.children.add(item);
			if (this.read(1).token == 'newline') {
				this.next();
				return true;
			}
			this.next();
		});
		return list;
	}
	
	/**
	 * トークンリーダを指定した分だけ進めます。
	 */
	void next([int step = 1]) {
		this.pos += step;
	}
	
	/**
	 * トークンリーダを指定した分だけ巻き戻します。
	 */
	void back([int step = 1]) {
		this.pos -= step;
	}
	
	/**
	 * 現在のトークンリーダの位置にあるトークンを読み出します。
	 */
	Token read([int relative_pos = 0]) {
		int pos = this.pos + relative_pos;
		if (pos >= this.tokens.length) {
			Token token = new Token();
			token.token = 'eof';
			token.lexeme = '';
			return token;
			//throw new Exception("Reader over");
		} else if (pos < 0) {
			Token token = new Token();
			token.token = 'sof';
			token.lexeme = '';
			return token;
		} else {
			return this.tokens[pos];
		}
	}
	
	/**
	 * ソースを走査します。トークンに出会う度に指定されたスキャナが呼ばれます。
	 * スキャナが [true] を返した場合、そこで直ちに走査は終了し、関数が終了します。
	 */
	void scan(bool scanner(Token token)) {
		while ((this.pos) < this.tokens.length) {
			Token token = this.read();
			//print(token);
			if (scanner(token) == true) {
				break;
			}	
		}
	}
}
